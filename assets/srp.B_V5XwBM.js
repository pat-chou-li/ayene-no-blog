import{_ as c}from"./ValaxyMain.vue_vue_type_style_index_0_lang.on4_726D.js";import"./chunks/@vueuse/motion.Bf6_DV_X.js";import{e as p,u as b,a as h}from"./chunks/vue-router.CDV2LZ_i.js";import{aa as P,aq as r,ag as n,af as e,ai as a,F as g,ab as C,Z as R}from"./framework.DmXNyegR.js";import"./app.CZR6THSy.js";import"./chunks/dayjs.BdcnXKr1.js";import"./chunks/vue-i18n.DfFCechf.js";import"./chunks/pinia.DvPpdoxl.js";/* empty css                    */import"./chunks/nprogress.Bru8d7fl.js";import"./YunComment.vue_vue_type_style_index_0_lang.BaUdOGFx.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.D2Q9Gv0h.js";import"./post.CDDobuH6.js";const S="/ayene-no-blog/assets/image-20231014170229647.DAMW4Kpi.png",x=p("/posts/cg/srp",async t=>JSON.parse('{"title":"SRP","description":"","frontmatter":{"title":"SRP","date":"2023-10-15","categories":"图形学","tags":["图形学","Unity"]},"headers":[],"relativePath":"pages/posts/cg/srp.md","lastUpdated":1764579964000}'),{lazy:(t,s)=>t.name===s.name}),V={__name:"srp",setup(t,{expose:s}){const{data:i}=x(),d=h(),f=b(),o=Object.assign(f.meta.frontmatter||{},i.value?.frontmatter||{});return d.currentRoute.value.data=i.value,R("valaxy:frontmatter",o),globalThis.$frontmatter=o,s({frontmatter:{title:"SRP",date:"2023-10-15",categories:"图形学",tags:["图形学","Unity"]}}),(l,u)=>{const m=c;return C(),P(m,{frontmatter:g(o)},{"main-content-md":r(()=>[...u[0]||(u[0]=[e("h3",{id:"_1-自定义渲染管线",tabindex:"-1"},[a("1. 自定义渲染管线 "),e("a",{class:"header-anchor",href:"#_1-自定义渲染管线","aria-label":'Permalink to "1. 自定义渲染管线"'},"​")],-1),e("figure",null,[e("img",{src:S,alt:"image-20231014170229647",loading:"lazy",decoding:"async"})],-1),e("h4",{id:"renderpipelineasset类",tabindex:"-1"},[a("RenderPipelineAsset类 "),e("a",{class:"header-anchor",href:"#renderpipelineasset类","aria-label":'Permalink to "RenderPipelineAsset类"'},"​")],-1),e("p",null,"用来创建管线的类",-1),e("p",null,"继承此类实现CreatePipeline，可以创建一个CustomRenderPipeline，在Project Settings中设置为该渲染管线，就可以用自己的自定义管线了。",-1),e("h4",{id:"renderpipeline类",tabindex:"-1"},[a("RenderPipeline类 "),e("a",{class:"header-anchor",href:"#renderpipeline类","aria-label":'Permalink to "RenderPipeline类"'},"​")],-1),e("p",null,[a("Unity"),e("strong",null,"每一帧"),a("都会调用CustomRenderPipeline实例的Render()方法进行画面渲染，该方法是SRP的入口。")],-1),e("p",null,"进行渲染时底层接口会调用它并传递两个参数，一个是ScriptableRenderContext对象，一个是Camera[]对象。",-1),e("p",null,"ScriptableRenderContext和CommandBuffer是SRP用于渲染的最底层接口。",-1),e("p",null,"Camera[]是相机数组，存储了参与这一帧的所有相机对象",-1),e("h4",{id:"camerarenderer类",tabindex:"-1"},[a("CameraRenderer类 "),e("a",{class:"header-anchor",href:"#camerarenderer类","aria-label":'Permalink to "CameraRenderer类"'},"​")],-1),e("p",null,"相机管理类，每一个相机渲染是互相独立的，用这个类去进行每个相机单独的渲染。",-1),e("p",null,[a("在这里"),e("strong",null,"实现render方法"),a("，在RenderPipeline类中实例化一个CameraRenderer循环调用render方法，通过多态完成相机独立渲染（如何进行多态实现方式后面补）。")],-1),e("h4",{id:"render方法实现",tabindex:"-1"},[a("Render方法实现 "),e("a",{class:"header-anchor",href:"#render方法实现","aria-label":'Permalink to "Render方法实现"'},"​")],-1),e("ul",null,[e("li",null,[e("p",null,"Setup()"),e("ul",null,[e("li",null,"在提交渲染命令前，要设置相机的VP矩阵以及相机的其他属性，封装在Setup方法中。如调用context.SetupCameraProperties(camera)")])]),e("li",null,[e("p",null,"DrawVisibleGeometry()"),e("ul",null,[e("li",null,"定义一个DrawVisibleGeometry()方法，在其中用context的接口来发送渲染命令，如context.DrawSkybox(camera)来绘制天空盒。")])]),e("li",null,[e("p",null,"Submit()"),e("ul",null,[e("li",null,"但是context提交的渲染命令都是缓冲的，我们还需要调用context.submit()正式提交渲染命令。")])])],-1),e("h4",{id:"commandbuffer",tabindex:"-1"},[a("CommandBuffer "),e("a",{class:"header-anchor",href:"#commandbuffer","aria-label":'Permalink to "CommandBuffer"'},"​")],-1),e("p",null,"某些任务，如绘制天空盒，可以直接由context发出",-1),e("p",null,"而另外的命令需要通过单独的命令缓冲区间接发出，用来绘制场景中其他几何图形。",-1),e("p",null,"CommandBuffer是一个容器，保存了这些将要执行的渲染命令。",-1),e("h5",{id:"buffer-beginsample方法和buffer-endsample方法",tabindex:"-1"},[a("buffer.BeginSample方法和buffer.EndSample方法 "),e("a",{class:"header-anchor",href:"#buffer-beginsample方法和buffer-endsample方法","aria-label":'Permalink to "buffer.BeginSample方法和buffer.EndSample方法"'},"​")],-1),e("div",{class:"language-"},[e("button",{title:"Copy code",class:"copy"}),e("span",{class:"lang"}),e("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[e("code",{"v-pre":""},[e("span",{class:"line"},[e("span",null,"//在Profiler和Frame Debugger中开启对Command buffer的监测")]),a(`
`),e("span",{class:"line"},[e("span",null,"buffer.BeginSample(bufferName);")])])]),e("button",{class:"code-block-unfold-btn"})],-1),e("p",null,"通常放在整个渲染过程的开始和结束，传参命令缓冲区的名字",-1),e("h5",{id:"context-executebuffer-buffer-方法",tabindex:"-1"},[a("context.ExecuteBuffer(buffer)方法 "),e("a",{class:"header-anchor",href:"#context-executebuffer-buffer-方法","aria-label":'Permalink to "context.ExecuteBuffer(buffer)方法"'},"​")],-1),e("p",null,"执行buffer中的渲染命令",-1),e("p",null,"执行完后如果想重用这个buffer，需要调用buffer.clear()",-1),e("h5",{id:"rendertarget",tabindex:"-1"},[a("RenderTarget "),e("a",{class:"header-anchor",href:"#rendertarget","aria-label":'Permalink to "RenderTarget"'},"​")],-1),e("p",null,"Render Target指的是摄像机应该渲染到的地方，这个地方要么是Frame Buffer（也就是最终会输出到屏幕上的buffer），要么是Render Texture（我们自己创建的渲染纹理，这张纹理可以用来做任何事，当然也可以当frame buffer用）。",-1),e("h5",{id:"buffer-clearrendertarget-bool-bool-rgb-方法",tabindex:"-1"},[a("buffer.ClearRenderTarget(bool, bool, rgb)方法 "),e("a",{class:"header-anchor",href:"#buffer-clearrendertarget-bool-bool-rgb-方法","aria-label":'Permalink to "buffer.ClearRenderTarget(bool, bool, rgb)方法"'},"​")],-1),e("p",null,"为了保证下一帧绘制的图像正确，我们通常要清除RenderTarget，清除旧的数据。该操作通过调用buffer.ClearRenderTarget方法来完成",-1),e("p",null,"该方法有三个参数，前两个参数用来设置是否需要清除深度数据和颜色数据，这里我们都设为true，第三个参数设置清除颜色数据的颜色，我们设置为Color.clear。我们在Setup()中一开始就调用它。",-1),e("p",null,"[注意] 特别注意要先设置SetupCameraProperties(camera)再清空渲染目标，否则unity不知道要清除的渲染目标在哪，只能通过draw GL来绘制一个全屏的四边形面片来完成清除RT的任务",-1),e("h4",{id:"剔除",tabindex:"-1"},[a("剔除 "),e("a",{class:"header-anchor",href:"#剔除","aria-label":'Permalink to "剔除"'},"​")],-1),e("p",null,"通过camera.TryGetCullingParameters方法得到需要进行剔除检查的物体",-1),e("p",null,"通过context.Cull进行正式剔除",-1),e("h3",{id:"_2-draw-call",tabindex:"-1"},[a("2.Draw Call "),e("a",{class:"header-anchor",href:"#_2-draw-call","aria-label":'Permalink to "2.Draw Call"'},"​")],-1),e("h4",{id:"drawcall具体组成-以及setpass-call",tabindex:"-1"},[a("DrawCall具体组成，以及SetPass Call "),e("a",{class:"header-anchor",href:"#drawcall具体组成-以及setpass-call","aria-label":'Permalink to "DrawCall具体组成，以及SetPass Call"'},"​")],-1),e("p",null,[a("对于我们已经见过的Draw Call，我们再提一次Draw Call的定义为"),e("strong",null,"CPU调用图像编程接口以命令GPU进行渲染操作"),a("。以及，"),e("strong",null,"DrawCall本身只是一条指令，并不怎么耗时。")],-1),e("p",null,"真正耗时的是drawcall之前提交数据，以及设置渲染状态。",-1),e("p",null,"我们知道在发生一次Draw Call之前，CPU需要做两件事：1，把数据加载到显存，即把网格顶点、法线、纹理等加载到显存中；2，设置渲染状态，包括定义网格使用哪个纹理、哪个材质，还有光源属性等。",-1),e("p",null,"那么我们理解了，GPU想要进行一次渲染操作（Draw Call)，粗略看来需要两类信息：1，Mesh顶点；2，材质信息。（实际肯定更复杂）",-1),e("p",null,"对于第一类信息，CPU会在Draw Call前提交一次网格数据(顶点、顶点颜色、法线等）。",-1),e("p",null,[a("对于第二类信息，材质信息我们可以把它理解成渲染状态，CPU会在Draw Call前进行一次设置渲染状态。设置渲染状态流程：CPU首先会"),e("strong",null,"判断当前GPU中当前渲染状态是否为需要的渲染状态"),a("，如果是，则不用更改渲染状态，完成设置；如果不是，则设置为新的渲染状态，也叫做"),e("strong",null,"更换渲染状态"),a("，而更换渲染状态也就叫做"),e("strong",null,"SetPass Call"),a("。对于SetPass Call我们必须知道的一点是，"),e("strong",null,"SetPass Call非常耗时！！！")],-1),e("h4",{id:"srp-batcher",tabindex:"-1"},[a("SRP Batcher "),e("a",{class:"header-anchor",href:"#srp-batcher","aria-label":'Permalink to "SRP Batcher"'},"​")],-1),e("p",null,[e("a",{href:"https://zhuanlan.zhihu.com/p/594539671",target:"_blank",rel:"noreferrer"},"https://zhuanlan.zhihu.com/p/594539671")],-1),e("p",null,"SRP Batcher被打断的判断依据是是否更换了shader，而并非动态批处理那样是否更换了材质。",-1),e("p",null,[e("strong",null,"SRP Batcher的作用就是尽可能减少耗时的SetPass Call"),a("，也就是说SRP Batcher并不会减少Draw Call次数，而是减少每次Draw Call触发SetPass Call的可能性。而SRP Batcher之所以能够实现的大功臣就是CBUFFER。")],-1),e("p",null,"SRP Batcher会在主存中将模型的坐标信息、材质信息、主光源阴影参数和非主光源阴影参数分别保存到不同的CBUFFER(常量缓冲区）中，只有CBUFFER发生变化才会重新提交到GPU并保存。",-1),e("p",null,[a("在DrawRenderers开始时，SRP Batcher一次将本次DrawRenderers中所有（支持SRP Batcher）的材质和每个物体的部分信息（如变换矩阵）都提交到了显存中，然后"),e("strong",null,"CPU会在每次发送DrawCall前告诉GPU本次绘制需要使用哪一部分CBuffer"),a("。")],-1),e("p",null,"【总结：将同一shader的物体的信息装到比较大的cbuffer中，提交一次，然后每次渲染让GPU选择部分cbuffer的信息使用】",-1),e("h4",{id:"gpu-instancing",tabindex:"-1"},[a("GPU Instancing "),e("a",{class:"header-anchor",href:"#gpu-instancing","aria-label":'Permalink to "GPU Instancing"'},"​")],-1),e("p",null,[e("strong",null,"将多个使用相同Mesh相同Material的Objects放在一次Draw Call中绘制"),a("。其中，"),e("strong",null,"不同Object的材质属性可以不同"),a("。CPU会收集每个物体的Transform信息和Material Properties然后构建成一个数组发送给GPU。GPU根据数组迭代绘制每个实体。")],-1)])]),"main-header":r(()=>[n(l.$slots,"main-header")]),"main-header-after":r(()=>[n(l.$slots,"main-header-after")]),"main-nav":r(()=>[n(l.$slots,"main-nav")]),"main-content-before":r(()=>[n(l.$slots,"main-content-before")]),"main-content":r(()=>[n(l.$slots,"main-content")]),"main-content-after":r(()=>[n(l.$slots,"main-content-after")]),"main-nav-before":r(()=>[n(l.$slots,"main-nav-before")]),"main-nav-after":r(()=>[n(l.$slots,"main-nav-after")]),comment:r(()=>[n(l.$slots,"comment")]),footer:r(()=>[n(l.$slots,"footer")]),aside:r(()=>[n(l.$slots,"aside")]),"aside-custom":r(()=>[n(l.$slots,"aside-custom")]),default:r(()=>[n(l.$slots,"default")]),_:3},8,["frontmatter"])}}};export{V as default,x as usePageData};
