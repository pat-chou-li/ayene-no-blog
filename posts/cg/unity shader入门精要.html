<!DOCTYPE html><html lang="en" data-beasties-container><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/favicon.svg"><script>!function(){const e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("vueuse-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script><style type="text/css">:root{color-scheme:light dark;--va-c-bg:#fff}html{background-color:var(--va-c-bg)}</style><script>const locale=localStorage.getItem("valaxy-locale")||"zh-CN";document.documentElement.setAttribute("lang",locale)</script><script type="module" async crossorigin src="/ayene-no-blog/assets/app.CZR6THSy.js"></script><link rel="modulepreload" crossorigin href="/ayene-no-blog/assets/framework.DmXNyegR.js"><link rel="modulepreload" crossorigin href="/ayene-no-blog/assets/chunks/@vueuse/motion.Bf6_DV_X.js"><link rel="modulepreload" crossorigin href="/ayene-no-blog/assets/chunks/vue-router.CDV2LZ_i.js"><link rel="modulepreload" crossorigin href="/ayene-no-blog/assets/chunks/dayjs.BdcnXKr1.js"><link rel="modulepreload" crossorigin href="/ayene-no-blog/assets/chunks/vue-i18n.DfFCechf.js"><link rel="modulepreload" crossorigin href="/ayene-no-blog/assets/chunks/pinia.DvPpdoxl.js"><link rel="modulepreload" crossorigin href="/ayene-no-blog/assets/chunks/nprogress.Bru8d7fl.js"><link rel="stylesheet" crossorigin href="/ayene-no-blog/assets/app.Dgo4sgoW.css"><link rel="stylesheet" crossorigin href="/ayene-no-blog/assets/group-icons.Bm1YPxXM.css"><link rel="modulepreload" crossorigin href="/ayene-no-blog/assets/post.sr24ljMs.js"><link rel="stylesheet" href="/ayene-no-blog/assets/group-icons.Bm1YPxXM.css"><link rel="modulepreload" crossorigin href="/ayene-no-blog/assets/unity shader入门精要.vxG1e5JL.js"><title>Unity shader 入门精要 - ayane no blog</title><script id="check-mac-os" async>document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap"><meta property="og:locale:alternate" content="en"><meta name="description" content="我从来没有觉得学图形学开心过。"><meta property="og:description" content="我从来没有觉得学图形学开心过。"><meta property="og:locale" content="zh-CN"><meta property="og:site_name" content="ayane no blog"><meta property="og:title" content="Unity shader 入门精要"><meta property="og:image" content="/favicon.svg"><meta property="og:type" content="website"><meta property="og:url" content="https://pat-chou-li.github.io/ayene-no-blog/"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><meta name="generator" content="Valaxy 0.26.10"><meta name="theme-color" content="#fff"><meta name="msapplication-TileColor" content="#fff"><meta name="twitter:card" content="summary_large_image"></head><body><div id="app" data-server-rendered="true"><!--[--><!--[--><!--[--><!----><!----><div class="yun-page-header-gradient" style="--gradient-from:161 196 253;--gradient-to:194 233 251"></div><!----><!----><!----><canvas class="fireworks"></canvas><!--[--><div class="yun-bg"></div><!--]--><div class="yun-page-loading" absolute left-0 right-0 bottom-0 top-0 flex justify="center" items-center z-10 bg="$va-c-bg" data-v-673bc094><div class="spinner" data-v-673bc094></div></div><a href="#" class="back-to-top yun-icon-btn bg-$va-c-bg-soft shadow-md"><div class="size-8" i-ri-arrow-up-s-line></div><svg class="progress-circle-container" viewBox="0 0 100 100"><circle stroke-dasharray="301.59289474462014 301.59289474462014" stroke-dashoffset="301.59289474462014" stroke="currentColor" stroke-width="2" stroke-linecap="round" class="progress-circle" cx="50" cy="50" r="48" fill="none"/></svg></a><!-- TODO --><!-- <YunDock /> --><!--]--><!--[--><!--]--><!----><!--]--><!--[--><div flex="~" class="w-full m-auto justify-center items-start gap-4 mt-12 md:mt-24"><!--[--><!----><main class="yun-main lt-md:w-full" flex="~ center"><!--[--><div class="content w-full md:w-3xl lg:w-2xl xl:w-2xl 2xl:w-4xl" flex="~ col grow" p="lt-md:0"><div class="yun-card flex-center rounded-2 relative" flex="col" min-h="100px" bg="$va-c-bg-light" m="0" style><!----><!----><!--[--><div class="mt-8 mb-4"><!--[--><header class="post-header"><h1 p="2" text="2xl center" font="serif black" style="" class="post-title flex-center"><!----><span inline-flex class="leading-none">Unity shader 入门精要</span></h1></header><!--]--></div><!--[--><!--[--><!--[--><!--[--><!----><!----><!----><div flex="~ center" text="sm" class="flex-col gap-2! post-meta gap-4"><div class="post-time flex items-center gap-4"><span class="posted-time inline-flex-center gap-1" title="发表于2023-09-29 00:00:00"><div class="inline-block" i-ri-calendar-line></div><time class="op-80">2023-09-29</time></span><!----></div><!--[--><!--]--><div class="inline-flex-center gap-4"><!----><!----></div></div><!--]--><div class="inline-flex mt-2" text="sm" py="1"><a href="/ayene-no-blog/categories?category=%E5%9B%BE%E5%BD%A2%E5%AD%A6" class="transition post-category inline-flex-center text-xs border-$va-c-divider" px-2 h="7" border rounded-full hover="bg-blue-500 text-white"><div m="x-1" inline-flex i-ri-folder-2-line></div><span>图形学</span></a><span mx="2"></span><div class="post-tags inline-flex" items="center" gap="1" flex="wrap 1" justify="end"><!--[--><a href="/ayene-no-blog/tags/?tag=%E5%9B%BE%E5%BD%A2%E5%AD%A6" class="transition post-tag inline-flex-center text-xs border-$va-c-divider" px-2 h="7" rounded-full border hover="bg-blue-500 text-white"><span>图形学</span></a><a href="/ayene-no-blog/tags/?tag=Unity" class="transition post-tag inline-flex-center text-xs border-$va-c-divider" px-2 h="7" rounded-full border hover="bg-blue-500 text-white"><span>Unity</span></a><!--]--></div></div><!--]--><!--]--><!--]--><div p="x-4 b-8" class="sm:px-6 lg:px-12 xl:px-16" w="full"><!--[--><!--]--><!--[--><!-- <Transition appear> --><article class="markdown-body"><!--[--><!----><blockquote class="yun-time-warning" op="80">本文最后更新于 2 年前，文中所描述的信息可能已发生改变。</blockquote><!--[--><!--]--><!--[--><h3 id="第三章" tabindex="-1">第三章 <a class="header-anchor" href="#第三章" aria-label="Permalink to &quot;第三章&quot;">​</a></h3><h5 id="semantic" tabindex="-1">semantic <a class="header-anchor" href="#semantic" aria-label="Permalink to &quot;semantic&quot;">​</a></h5><figure><img src="/ayene-no-blog/assets/image-20230928155528032.89yPaMeC.png" alt="image-20230928155528032" loading="lazy" decoding="async"></figure><h3 id="第六章" tabindex="-1">第六章 <a class="header-anchor" href="#第六章" aria-label="Permalink to &quot;第六章&quot;">​</a></h3><h5 id="phone和binn-phone的区别" tabindex="-1">phone和Binn-Phone的区别： <a class="header-anchor" href="#phone和binn-phone的区别" aria-label="Permalink to &quot;phone和Binn-Phone的区别：&quot;">​</a></h5><p>在计算高光时是否采用半程向量简化运算</p><figure><img src="/ayene-no-blog/assets/image-20230928163501854.DuJRStj6.png" alt="image-20230928163501854" loading="lazy" decoding="async"></figure><h4 id="半兰伯特模型" tabindex="-1">半兰伯特模型 <a class="header-anchor" href="#半兰伯特模型" aria-label="Permalink to &quot;半兰伯特模型&quot;">​</a></h4><figure><img src="/ayene-no-blog/assets/image-20230928172352809.sLy_rt6m.png" alt="image-20230928172352809" loading="lazy" decoding="async"></figure><h4 id="光照模型" tabindex="-1">光照模型 <a class="header-anchor" href="#光照模型" aria-label="Permalink to &quot;光照模型&quot;">​</a></h4><p>漫反射实现的公式为_LightColor0.rgb * albedo * saturate(dot(normal, lightDir))</p><figure><img src="/ayene-no-blog/assets/image-20231001193213409.C12XlioS.png" alt="image-20231001193213409" loading="lazy" decoding="async"></figure><p>高光中也有对应的高光反射项，前面的练习中都用_specular来控制</p><figure><img src="/ayene-no-blog/assets/image-20231001193234969.Dn00j-41.png" alt="image-20231001193234969" loading="lazy" decoding="async"></figure><p>环境光实现时公式为UNITY_LIGHTMODEL_AMBIENT * albedo;</p><p>albedo由纹理和物体本身的颜色（_color）控制，unity官网中定义为</p><p>albedo := base（diffuse or specular）color</p><p>和漫反射共用albedo</p><figure><img src="/ayene-no-blog/assets/image-20231001193304011.ncB6hst8.png" alt="image-20231001193304011" loading="lazy" decoding="async"></figure><p>总之：高光最特殊，只看灯光颜色和高光颜色，其他的光照都和自己的颜色（_Color）以及纹理有关，统一用一个albedo（反射率）表示</p><h4 id="小结-颜色的乘法和加法" tabindex="-1">小结：颜色的乘法和加法 <a class="header-anchor" href="#小结-颜色的乘法和加法" aria-label="Permalink to &quot;小结：颜色的乘法和加法&quot;">​</a></h4><p>不同rgb值的乘法可以理解为光与物体的交互过程，例如物体的颜色（或纹理）其实是物体对光的吸收率，当然要乘以光的颜色。</p><p>不同rgb值的加法是对不同的光照过程的叠加，例如我们把phone模型分解成环境光、漫反射和高光，是三种没有交互的光照过程，就需要叠加。或者是多个光源叠加的时候。</p><h3 id="第七章" tabindex="-1">第七章 <a class="header-anchor" href="#第七章" aria-label="Permalink to &quot;第七章&quot;">​</a></h3><p>o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</p><p>等价于</p><p>o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</p><p>想象把uv坐标分别拉长xy倍，就要更多的纹理才能铺平它，所以纹理会更加密集</p><h4 id="凹凸映射-法线贴图" tabindex="-1">凹凸映射（法线贴图） <a class="header-anchor" href="#凹凸映射-法线贴图" aria-label="Permalink to &quot;凹凸映射（法线贴图）&quot;">​</a></h4><p><a href="https://blog.csdn.net/qq_41835314/article/details/126558410" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_41835314/article/details/126558410</a></p><p>为什么绝对法线坐标（模型空间下的法线贴图）不能进行uv动画？想象一个球体，上方的上凸，右边的右凸，移动两个地方的贴图，会导致右边的上凸，这样是不对的。如果存储的是相对坐标就可以做到。在切线空间中都是相对于切线空间的平面上凸。</p><h4 id="tbn矩阵" tabindex="-1">TBN矩阵 <a class="header-anchor" href="#tbn矩阵" aria-label="Permalink to &quot;TBN矩阵&quot;">​</a></h4><figure><img src="/ayene-no-blog/assets/image-20231006153756685.DDZiPjzi.png" alt="image-20231006153756685" loading="lazy" decoding="async"></figure><p>通过宏 #TANGENT_SPACE_ROTATION可以获得TBN矩阵，用来将坐标从模型空间转换至切线空间</p><p>可以知道Unity是行主元的，将TBN进行行排布就可以得到TBN矩阵</p><h4 id="遮罩纹理" tabindex="-1">遮罩纹理 <a class="header-anchor" href="#遮罩纹理" aria-label="Permalink to &quot;遮罩纹理&quot;">​</a></h4><p>回到101中所讲的话题，纹理就是显存中的一片区域，可以存储任何你想控制的东西。在这本书中用高光遮罩来举例，可以控制模型上每一点在遇到高光的时候要做哪些特殊处理，使得模型不同的地方遇到相同的高光时拥有不一样的表现。</p><h3 id="第八章" tabindex="-1">第八章 <a class="header-anchor" href="#第八章" aria-label="Permalink to &quot;第八章&quot;">​</a></h3><h4 id="透明度测试" tabindex="-1">透明度测试 <a class="header-anchor" href="#透明度测试" aria-label="Permalink to &quot;透明度测试&quot;">​</a></h4><p>透明度测试是指给定一个透明度阈值，当片元的透明度高于阈值时不渲染，否则就渲染，要么完全显示，要么不显示，不能实现半透明</p><h4 id="透明度混合" tabindex="-1">透明度混合 <a class="header-anchor" href="#透明度混合" aria-label="Permalink to &quot;透明度混合&quot;">​</a></h4><p>先渲染不透明物体，然后关闭深度写入，为透明物体排序，先渲染靠后的透明物体，渲染透明物体时blend原像素值和新像素值。</p><p>排序透明物体很容易出问题，可能会出现互相遮挡的情况。</p><h5 id="透明度混合中启用深度写入" tabindex="-1">透明度混合中启用深度写入 <a class="header-anchor" href="#透明度混合中启用深度写入" aria-label="Permalink to &quot;透明度混合中启用深度写入&quot;">​</a></h5><p>在真正渲染前增加一个pass</p><figure><img src="/ayene-no-blog/assets/image-20231002140030394.B1715Ed5.png" alt="image-20231002140030394" loading="lazy" decoding="async"></figure><p>ColorMask设置写掩码，0时不会写入任何颜色，因此该pass只写入深度缓存</p><figure><img src="/ayene-no-blog/assets/image-20231002140112523.6ZlyadUs.png" alt="image-20231002140112523" loading="lazy" decoding="async"></figure><h4 id="渲染队列" tabindex="-1">渲染队列 <a class="header-anchor" href="#渲染队列" aria-label="Permalink to &quot;渲染队列&quot;">​</a></h4><figure><img src="/ayene-no-blog/assets/image-20231003145722118.BxzoAAGy.png" alt="image-20231003145722118" loading="lazy" decoding="async"></figure><p>通过标签声明，决定此pass的渲染顺序</p><h4 id="shaderlab的混合命令" tabindex="-1">ShaderLab的混合命令 <a class="header-anchor" href="#shaderlab的混合命令" aria-label="Permalink to &quot;ShaderLab的混合命令&quot;">​</a></h4><p>不仅仅可以混合半透明物体，还可以进行其他混合。</p><p>我们首先来看一下混合是如何实现的。当片元着色器产生一个颜任的时候，可以选择与颜色缓存中的颜色进行混合。这样一来，混合就和两个操作数有关:<strong>源颜色(source color)<strong>和</strong>目标颜色(destination color)</strong>。</p><ul><li><p><strong>源颜色</strong>，我们用<strong>S</strong>表示，指的是由<strong>片元着色器</strong>产生的颜色值;</p></li><li><p><strong>目标颜色</strong>，我们用<strong>D</strong>表示，指的是从<strong>颜色缓冲</strong>中读取到的颜色值。</p></li><li><p>对它们进行混合后得到的<strong>输出颜色</strong>，我们<strong>O</strong>表示，它会重新写入到颜色缓冲中。</p><p>需要注意的是，当我们谈及混合中的源颜色、目标颜色和输出颜色时，它们都包含了RGBA四个通道的值，而并非仅仅是RGB通道。</p></li></ul><figure><img src="/ayene-no-blog/assets/image-20231002142204965.DS7DU2Zp.png" alt="image-20231002142204965" loading="lazy" decoding="async"></figure><p>例如<img src="data:image/png;base64,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" alt="image-20231002142224254"></p><p>就表示 源颜色*源透明度 + 目标颜色*（1-源透明度）</p><h3 id="第九章" tabindex="-1">第九章 <a class="header-anchor" href="#第九章" aria-label="Permalink to &quot;第九章&quot;">​</a></h3><h4 id="前向渲染" tabindex="-1">前向渲染 <a class="header-anchor" href="#前向渲染" aria-label="Permalink to &quot;前向渲染&quot;">​</a></h4><h5 id="base-pass和additional-pass" tabindex="-1">Base Pass和Additional Pass <a class="header-anchor" href="#base-pass和additional-pass" aria-label="Permalink to &quot;Base Pass和Additional Pass&quot;">​</a></h5><p>base pass用来计算平行光（尽管平行光逐像素），逐顶点的光源和SH光源，不管有几个光源都只执行一次，在一次pass中将所有base pass涉及的光源全部计算。</p><p>Addtional Pass用来计算逐像素的光源，根据有几个逐像素光源执行多次，并最后进行Blend One One。</p><h4 id="延迟渲染" tabindex="-1">延迟渲染 <a class="header-anchor" href="#延迟渲染" aria-label="Permalink to &quot;延迟渲染&quot;">​</a></h4><h5 id="延迟渲染和z-prepass有什么区别-或者说延迟渲染和前向渲染在时间复杂度上的区别究竟是怎么来的" tabindex="-1">延迟渲染和Z-Prepass有什么区别？或者说延迟渲染和前向渲染在时间复杂度上的区别究竟是怎么来的？ <a class="header-anchor" href="#延迟渲染和z-prepass有什么区别-或者说延迟渲染和前向渲染在时间复杂度上的区别究竟是怎么来的" aria-label="Permalink to &quot;延迟渲染和Z-Prepass有什么区别？或者说延迟渲染和前向渲染在时间复杂度上的区别究竟是怎么来的？&quot;">​</a></h5><p>Z-prepass也是先跑一遍渲染，存下Z-buffer，之后在片元着色中对比z值来决定是否discard</p><p>但是Z-prepass仍然是一种前向渲染，仍然是一个双重循环，只是进行了剪枝。即仍然还是对每个模型的n个（可见）片元，根据光源数量m进行n*m次计算</p><p>而延迟渲染在计算光照时已经和每个模型有几个片元无关，是在一张G-buffer上计算的，即二重循环变为屏幕的像素数量n和光源数量m，n为常数的情况下，m的增加影响就较小。</p><p>那么总结到延迟渲染和前向渲染的根本区别，就在于延迟渲染通过增加一个pass，将该几何体的每个片元的信息映射到一个Gbuffer，一个二维平面中去，最后再进行光照计算。将原来的内循环（每个光源进行着色）放到第二个pass中。第二个pass的外循环是常数像素数量，而不是该模型的片元数量。</p><h4 id="阴影相关的宏-shadow-map" tabindex="-1">阴影相关的宏（Shadow Map） <a class="header-anchor" href="#阴影相关的宏-shadow-map" aria-label="Permalink to &quot;阴影相关的宏（Shadow Map）&quot;">​</a></h4><p>本书写的不够详细，建议复习shadow map相关内容。</p><figure><img src="/ayene-no-blog/assets/image-20231006154446839.C0axoUJT.png" alt="image-20231006154446839" loading="lazy" decoding="async"></figure><p>SHADOW_COORDS : 声明纹理坐标（类似uv）</p><p>TRANSFER_SHADOW : 计算阴影纹理的采样坐标，存储到SHADOW_COORDS中声明的纹理坐标</p><p>SHADOW_ATTENUATION：对光源空间中的纹理进行采样，得到阴影信息</p><h3 id="第十章" tabindex="-1">第十章 <a class="header-anchor" href="#第十章" aria-label="Permalink to &quot;第十章&quot;">​</a></h3><h4 id="立方体纹理" tabindex="-1">立方体纹理 <a class="header-anchor" href="#立方体纹理" aria-label="Permalink to &quot;立方体纹理&quot;">​</a></h4><figure><img src="/ayene-no-blog/assets/image-20231002192641415.DgDItJRs.png" alt="image-20231002192641415" loading="lazy" decoding="async"></figure><p>如何对一个立方体纹理进行采样？给出一个方向，从立方体中心出发，与立方体的交点就是采样点。</p><p>立方体纹理可以用来做环境映射，把环境所形成的贴图贴在立方体上，然后利用反射光进行采样。反射光就是图中所给出的方向。折射也是同样的道理。</p><p>天空盒也是用立方体纹理完成的，把天空贴在盒子上，给出一个视线方向，交点就是看到的天空的一个点。</p><h4 id="渲染目标纹理-reder-target-texture-rtt-和多重渲染目标-multiple-render-target-mrt" tabindex="-1">渲染目标纹理（Reder Target Texture,RTT）和多重渲染目标（Multiple Render Target, MRT） <a class="header-anchor" href="#渲染目标纹理-reder-target-texture-rtt-和多重渲染目标-multiple-render-target-mrt" aria-label="Permalink to &quot;渲染目标纹理（Reder Target Texture,RTT）和多重渲染目标（Multiple Render Target, MRT）&quot;">​</a></h4><p>RTT是指将渲染生成的图像存储到纹理中（当然，不一定要正常的渲染，比如可以只做深度测试等等，G-buffer的各种信息就是这么生成的），MRT就是可以将渲染的图像存储到多个纹理中，比如一次渲染产生了法线、颜色、深度，可以存储到多个不同的渲染目标上。</p><h4 id="grabpass-texturename" tabindex="-1"><code>GrabPass {“TextureName”}</code> <a class="header-anchor" href="#grabpass-texturename" aria-label="Permalink to &quot;```GrabPass {“TextureName”}```&quot;">​</a></h4><p>在渲染半透明物体的pass前使用，可以将渲染出的屏幕存储到一张纹理中，然后再渲染半透明物体，渲染的时候使用这张纹理来完成折射效果。（当然，要将该pass放在半透明队列中，保证在不透明物体渲染完成后才执行这些pass）</p><h3 id="第十一章" tabindex="-1">第十一章 <a class="header-anchor" href="#第十一章" aria-label="Permalink to &quot;第十一章&quot;">​</a></h3><h4 id="unity内置时间变量" tabindex="-1">Unity内置时间变量 <a class="header-anchor" href="#unity内置时间变量" aria-label="Permalink to &quot;Unity内置时间变量&quot;">​</a></h4><figure><img src="/ayene-no-blog/assets/image-20231003170036449.B-YKbyy6.png" alt="image-20231003170036449" loading="lazy" decoding="async"></figure><h4 id="序列帧动画" tabindex="-1">序列帧动画 <a class="header-anchor" href="#序列帧动画" aria-label="Permalink to &quot;序列帧动画&quot;">​</a></h4><p>类似精灵，把动画效果集成在一张纹理上，然后将[0, 1]的uv映射到子区域上，根据时间选择不同的子区域作为纹理</p><h4 id="顶点动画" tabindex="-1">顶点动画 <a class="header-anchor" href="#顶点动画" aria-label="Permalink to &quot;顶点动画&quot;">​</a></h4><p>顾名思义，在shader的顶点着色器中根据顶点的位置来完成动画。</p><h4 id="广告牌技术" tabindex="-1">广告牌技术 <a class="header-anchor" href="#广告牌技术" aria-label="Permalink to &quot;广告牌技术&quot;">​</a></h4><figure><img src="/ayene-no-blog/assets/image-20231003192350774.C8juu4w3.png" alt="image-20231003192350774" loading="lazy" decoding="async"></figure><p>广告牌技术是将某个多边形旋转，使它看起来永远朝向（或尽量朝向）摄像头。</p><p>先根据视线方向和向上的方向叉乘出第三个正交基，再旋转法线方向（也就是视线方向）（例如草坪，我们希望它永远向上，所以我们不旋转向上的方向）或者旋转向上的方向（保证法线方向不变，使得永远正对摄像机）（例如粒子效果）来移动对应的线条，使得三条线正交。</p><p>在代码实现中：</p><p>如果是旋转向上方向，就和上述的流程图一致，先normal x upDir得到第三个正交基，再通过normal x right得到新的UpDir</p><p>如果是旋转法线方向，直接将法线方向的y置为0，这样就已经使得法线与向上方向正交，同时保证upDir不变。</p><figure><img src="/ayene-no-blog/assets/image-20231003194219203.IuwqEBik.png" alt="image-20231003194219203" loading="lazy" decoding="async"></figure><h4 id="为什么顶点动画要关闭批处理" tabindex="-1">为什么顶点动画要关闭批处理 <a class="header-anchor" href="#为什么顶点动画要关闭批处理" aria-label="Permalink to &quot;为什么顶点动画要关闭批处理&quot;">​</a></h4><p>因为批处理会合并涉及到的模型，从而导致这些模型丢失各自的模型空间，于是如果顶点动画中涉及到在模型空间中进行顶点变换，就会不能正确生效。</p><h3 id="第十二章" tabindex="-1">第十二章 <a class="header-anchor" href="#第十二章" aria-label="Permalink to &quot;第十二章&quot;">​</a></h3><h4 id="屏幕后处理流程" tabindex="-1">屏幕后处理流程 <a class="header-anchor" href="#屏幕后处理流程" aria-label="Permalink to &quot;屏幕后处理流程&quot;">​</a></h4><figure><img src="/ayene-no-blog/assets/image-20231004174333688.CoccTAzh.png" alt="image-20231004174333688" loading="lazy" decoding="async"></figure><ul><li>摄像机添加后处理脚本</li><li>脚本中用OnRenderImage函数获得当前屏幕</li><li>调用Graphics.Blit 使用特定的shader进行后处理<ul><li>会传给shader src和dest，src就是一张纹理，实际上就是后处理前的渲染好的屏幕</li></ul></li></ul><h4 id="高斯模糊" tabindex="-1">高斯模糊 <a class="header-anchor" href="#高斯模糊" aria-label="Permalink to &quot;高斯模糊&quot;">​</a></h4><h5 id="如何进行迭代的高斯模糊" tabindex="-1">如何进行迭代的高斯模糊？ <a class="header-anchor" href="#如何进行迭代的高斯模糊" aria-label="Permalink to &quot;如何进行迭代的高斯模糊？&quot;">​</a></h5><p>在C#脚本中创建RTbuffer，将模糊结果暂存。</p><div class="language-c#"><button title="Copy code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code v-pre><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> rtW</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> src.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> downSample;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> rtH</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> src.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> downSample;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    RenderTexture</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> buffer0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> RenderTexture.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">GetTemporary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(rtW, rtH, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    buffer0.filterMode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> FilterMode.Bilinear;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // 先把原图像放进buffer0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    Graphics.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Blit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(src, buffer0);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> iterations; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        material.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">SetFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"_BlurSize"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1.0f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> blurSpread);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">        RenderTexture</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> buffer1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> RenderTexture.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">GetTemporary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(rtW, rtH, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">        //用第0个pass处理后（水平模糊），将结果存入buffer1,然后存回buffer0，再清空buffer1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        Graphics.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Blit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(buffer0, buffer1, material, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        RenderTexture.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">ReleaseTemporary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(buffer0);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        buffer0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> buffer1;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        buffer1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> RenderTexture.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">GetTemporary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(rtW, rtH, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">        // 竖直模糊后结果存入buffer1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        Graphics.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Blit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(buffer0, buffer1, material, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">        // 存回buffer0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        RenderTexture.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">ReleaseTemporary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(buffer0);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        buffer0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> buffer1;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    Graphics.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">Blit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(buffer0, dest);</span></span></code></pre><button class="code-block-unfold-btn"></button></div><h3 id="第十三章" tabindex="-1">第十三章 <a class="header-anchor" href="#第十三章" aria-label="Permalink to &quot;第十三章&quot;">​</a></h3><ul><li><p>只获取深度纹理</p><ul><li>前向渲染<ul><li>着色器替换技术：选择那些RenderType = Opaque的物体，判断渲染队列是否小于等于2500，是的话就使用它们投射阴影的pass渲染到深度纹理中。（之所以选用投射阴影的pass，是因为这个pass中正好有使用到深度，详细参考shadowmap）</li><li>如果有，直接使用深度缓存</li></ul></li><li>延迟渲染<ul><li>Gbuffer中就有深度纹理</li></ul></li></ul></li><li><p>同时获取深度纹理和法线纹理</p><ul><li>前向渲染：单独使用一个pass，观察空间的发现信息在纹理的R和G通道，深度信息在纹理的B和A通道。</li><li>延迟渲染：两者都在Gbuffer中，合并深度纹理和法线纹理即可。</li></ul></li></ul><h4 id="深度纹理的深度值是非线性的-要将其转换回线性空间" tabindex="-1">深度纹理的深度值是非线性的，要将其转换回线性空间 <a class="header-anchor" href="#深度纹理的深度值是非线性的-要将其转换回线性空间" aria-label="Permalink to &quot;深度纹理的深度值是非线性的，要将其转换回线性空间&quot;">​</a></h4><p>以转换回view空间为例，只要知道是如何从view空间到深度缓存的，做一个逆变化即可。</p><h4 id="只考虑摄像机移动的运动模糊-通过深度纹理重建世界坐标的方法1-逆vp矩阵" tabindex="-1">只考虑摄像机移动的运动模糊（通过深度纹理重建世界坐标的方法1：逆VP矩阵） <a class="header-anchor" href="#只考虑摄像机移动的运动模糊-通过深度纹理重建世界坐标的方法1-逆vp矩阵" aria-label="Permalink to &quot;只考虑摄像机移动的运动模糊（通过深度纹理重建世界坐标的方法1：逆VP矩阵）&quot;">​</a></h4><p>存储上一帧的VP矩阵和这一帧的VP矩阵</p><p>将像素坐标用这一帧的VP逆矩阵重建回世界坐标，再乘以上一帧的VP矩阵得到上一帧该世界坐标对应哪个屏幕坐标，得到两个屏幕坐标的差值来得到速度</p><p>由于是使用不同的VP矩阵来得到屏幕坐标差值的，也就是其实只考虑了相机的移动，两帧屏幕坐标的变量只有相机位置的不同。</p><div class="language-c#"><button title="Copy code" class="copy"></button><span class="lang">c#</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code v-pre><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// 总的来说 计算出当前像素对应的屏幕坐标和上一帧的屏幕坐标（先转到世界坐标，然后用上一帧的VP矩阵），计算速度</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">fixed4</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> frag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">v2f</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">) : SV_Target{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // 通过采样深度纹理获得该点深度值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    float</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> SAMPLE_DEPTH_TEXTURE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(_CameraDepthTexture, i.uv_depth);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    #</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">if</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> defined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">UNITY_REVERSED_Z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 1.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> d;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    #</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">endif</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // 从屏幕坐标映射回NDC 范围为[-1, 1]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    float4</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> H</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> float4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(i.uv.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, i.uv.y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // 从NDC回到世界空间</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    float4</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> mul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(_CurrentViewProjectionInverseMatrix, H);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    float4</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> worldPos</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> D </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> D.w;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // 当前屏幕空间</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    float4</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> currentPos</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> H;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // 上一帧屏幕空间</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    float4</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> previousPos</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> mul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(_PreviousViewProjectionMatrix, worldPos);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    previousPos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> previousPos.w;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // 计算像素的速度</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    float2</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> velocity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (currentPos.xy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> previousPos.xy) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 2.0f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    float2</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> uv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> i.uv;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    float4</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> tex2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(_MainTex, uv);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    uv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> velocity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> _BlurSize;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> it</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">; it </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">; it</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, uv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> velocity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> _BlurSize)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">        float4</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> currentColor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> tex2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(_MainTex, uv);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> currentColor;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> fixed4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(c.rgb, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre><button class="code-block-unfold-btn"></button></div><h3 id="通过深度纹理重建世界坐标的方法2-借用摄像机坐标" tabindex="-1">通过深度纹理重建世界坐标的方法2：借用摄像机坐标 <a class="header-anchor" href="#通过深度纹理重建世界坐标的方法2-借用摄像机坐标" aria-label="Permalink to &quot;通过深度纹理重建世界坐标的方法2：借用摄像机坐标&quot;">​</a></h3><p>某个像素的世界坐标可以表示为：</p><p><code>float4 worldPos =_WorldSpaceCameraPos + linearDepth * interpolatedRay;</code></p><p>即相机世界坐标 + 偏移量，其中linearDepth就是从深度纹理中经过转换得到的线性深度，interpolatedRay是一个从相机到目标物体的射线，包括了方向信息和距离信息。由顶点着色器输出并插值得到。</p><p>具体计算方法如下，对于任意一个interpolatedRay，可以由下图得到TL、RT、BL、BR经过线性插值得到</p><figure><img src="/ayene-no-blog/assets/image-20231005170220480.RFFGjgMg.png" alt="image-20231005170220480" loading="lazy" decoding="async"></figure><p>图中向量计算过程如下：</p><ul><li>先计算toTop，toRight，halfHeight</li><li>再用这三个向量互相组合来得到TL、TR、BL、BR</li></ul><figure><img src="/ayene-no-blog/assets/image-20231005170458442.DImrvg4b.png" alt="image-20231005170458442" loading="lazy" decoding="async"></figure><p>这时候得到的四个向量含有方向和欧氏距离，但是我们得到的线性深度值仅仅代表了z的偏移，而不是相机到某点的绝对距离，因此我们要将z的值转换到欧氏距离，利用相似三角形，以RT为例：</p><figure><img src="/ayene-no-blog/assets/image-20231005191441260.KSd3pffO.png" alt="image-20231005191441260" loading="lazy" decoding="async"></figure><figure><img src="/ayene-no-blog/assets/image-20231005191446013.BTP9Fq-j.png" alt="image-20231005191446013" loading="lazy" decoding="async"></figure><p>为什么只用计算4个顶点的射线就能插值出中间的任意片元？</p><figure><img src="/ayene-no-blog/assets/image-20231005192138363.DlQz95i5.png" alt="image-20231005192138363" loading="lazy" decoding="async"></figure><p>因为本来就只有4个顶点，由unity的光栅化自动进行插值。</p><h3 id="第十四章" tabindex="-1">第十四章 <a class="header-anchor" href="#第十四章" aria-label="Permalink to &quot;第十四章&quot;">​</a></h3><h4 id="绘制模型轮廓线的5种方法" tabindex="-1">绘制模型轮廓线的5种方法 <a class="header-anchor" href="#绘制模型轮廓线的5种方法" aria-label="Permalink to &quot;绘制模型轮廓线的5种方法&quot;">​</a></h4><figure><img src="/ayene-no-blog/assets/image-20231006133446878.CbBsNa3C.png" alt="image-20231006133446878" loading="lazy" decoding="async"></figure><h4 id="顶点外扩描边" tabindex="-1">顶点外扩描边 <a class="header-anchor" href="#顶点外扩描边" aria-label="Permalink to &quot;顶点外扩描边&quot;">​</a></h4><p>在view空间下，将背面的顶点沿着法线方向外扩，再以轮廓色颜色渲染背面即可获得轮廓线，最后再渲染正面即可获得描边后的图像。</p><h4 id="素描风格渲染" tabindex="-1">素描风格渲染 <a class="header-anchor" href="#素描风格渲染" aria-label="Permalink to &quot;素描风格渲染&quot;">​</a></h4><p>根据法线和光线的夹角，分为6个层级，用6张不同的纹理模拟不同光照下的漫反射效果。</p><h3 id="第十六章" tabindex="-1">第十六章 <a class="header-anchor" href="#第十六章" aria-label="Permalink to &quot;第十六章&quot;">​</a></h3><h4 id="批处理" tabindex="-1">批处理 <a class="header-anchor" href="#批处理" aria-label="Permalink to &quot;批处理&quot;">​</a></h4><p>合并可以合并的顶点数据，整理成更大的VBO（vertex Buffer Object）再调用drawcall发给GPU，来减少drawcall的数量</p><ul><li>动态批处理：unity自动进行，有很多情况下都会打断动态批处理，比如使用多个pass，网格顶点数量超过指定数目等等。</li><li>静态批处理：勾选hierarchy上的static即可开启，运行开始时，将需要静态批处理的模型合并到一个新的网格结构中，从此以后这些模型不可以被移动。缺点是合并后的模型要同时存在于内存中，比如合并了一千棵树，那么一千棵树的顶点都要在内存中。<ul><li>对不同材质的物体用静态批处理，仍然要使用多个drawcall，但是可以减少切换drawcall状态时的性能消耗。</li></ul></li></ul><p>材质不同一般是不可以用批处理的，但是可以通过一些方法让批处理可以使用：</p><p>如果纹理完全不同，我们可以合并纹理到一个更大的纹理中，称为图集，再进行批处理</p><p>如果纹理只有微小的不同，可以修改合并后的VBO中的数据。</p><p>[注] ：</p><ul><li>批处理需要将模型变换到世界空间然后合并，如果shader中存在一些基于模型空间下的运算就会出错，需要使用[DisableBatching]强制该模型不会被批处理。</li><li>一些透明物体要先保证绘制顺序，再看能否被批处理，如果不能满足就优先保证绘制顺序。</li></ul><h4 id="减少需要处理的顶点" tabindex="-1">减少需要处理的顶点 <a class="header-anchor" href="#减少需要处理的顶点" aria-label="Permalink to &quot;减少需要处理的顶点&quot;">​</a></h4><h5 id="优化几何体" tabindex="-1">优化几何体 <a class="header-anchor" href="#优化几何体" aria-label="Permalink to &quot;优化几何体&quot;">​</a></h5><p>尽可能减少三角面片的数目</p><p>一个正方体，边界上的顶点可能被不同的面共享，从而拥有不同的法线，但是GPU必须是一个顶点对应一条法线的，这时候GPU就会将一个顶点拆分成多个顶点。因此我们还可以移除不必要的硬边和纹理衔接，避免边界平滑和纹理分离。</p><h5 id="lod-level-of-detail" tabindex="-1">LOD（Level of Detail） <a class="header-anchor" href="#lod-level-of-detail" aria-label="Permalink to &quot;LOD（Level of Detail）&quot;">​</a></h5><p>为一个模型创建一个LOD Group，但这个模型在摄像机边缘或离摄像机很远的时候，采用更少面片的模型。</p><h5 id="遮挡剔除技术" tabindex="-1">遮挡剔除技术 <a class="header-anchor" href="#遮挡剔除技术" aria-label="Permalink to &quot;遮挡剔除技术&quot;">​</a></h5><p>消除在其他物件后面看不到的物件，避免计算看不到的顶点。</p><h4 id="减少需要处理的片元" tabindex="-1">减少需要处理的片元 <a class="header-anchor" href="#减少需要处理的片元" aria-label="Permalink to &quot;减少需要处理的片元&quot;">​</a></h4><h5 id="控制绘制顺序" tabindex="-1">控制绘制顺序 <a class="header-anchor" href="#控制绘制顺序" aria-label="Permalink to &quot;控制绘制顺序&quot;">​</a></h5><p>尽量保证物体从前往后绘制，这样后面的物体通不过深度测试，而避免了渲染。在Unity中，渲染队列&lt;2500（也就是不透明的物体）都是从前往后绘制的，因此我们尽量让物体都在不透明的渲染队列中。</p><p>也可以根据实际项目需求规定渲染顺序，比如fps游戏中自己的角色就优先绘制，敌人的角色大概率在掩体后面，所以可以先绘制场景的其他物体。</p><h5 id="尽量减少透明物体" tabindex="-1">尽量减少透明物体 <a class="header-anchor" href="#尽量减少透明物体" aria-label="Permalink to &quot;尽量减少透明物体&quot;">​</a></h5><p>从后往前绘制的透明物体，会大量造成overdraw（后面的物体白白渲染了）</p><h5 id="减少实时光照的阴影" tabindex="-1">减少实时光照的阴影 <a class="header-anchor" href="#减少实时光照的阴影" aria-label="Permalink to &quot;减少实时光照的阴影&quot;">​</a></h5><p>会带来额外的pass，同时打断动态批处理</p><h4 id="节省带宽" tabindex="-1">节省带宽 <a class="header-anchor" href="#节省带宽" aria-label="Permalink to &quot;节省带宽&quot;">​</a></h4><h5 id="减少纹理大小" tabindex="-1">减少纹理大小 <a class="header-anchor" href="#减少纹理大小" aria-label="Permalink to &quot;减少纹理大小&quot;">​</a></h5><p>mipmap，纹理最好是正方形且长宽为2的幂次</p><h5 id="利用分辨率缩放" tabindex="-1">利用分辨率缩放 <a class="header-anchor" href="#利用分辨率缩放" aria-label="Permalink to &quot;利用分辨率缩放&quot;">​</a></h5><p>减小分辨率</p><h4 id="减少计算复杂度" tabindex="-1">减少计算复杂度 <a class="header-anchor" href="#减少计算复杂度" aria-label="Permalink to &quot;减少计算复杂度&quot;">​</a></h4><h5 id="lod-of-shader" tabindex="-1">LOD of Shader <a class="header-anchor" href="#lod-of-shader" aria-label="Permalink to &quot;LOD of Shader&quot;">​</a></h5><p>同模型的LOD，可以在shader中设置shader的LOD，为不同的情况使用不同的shader</p><h5 id="代码方面" tabindex="-1">代码方面 <a class="header-anchor" href="#代码方面" aria-label="Permalink to &quot;代码方面&quot;">​</a></h5><p>尽量使用更低精度的浮点，如fixed/lowp，避免使用float</p><p>尽量避免不同精度的转换</p><p>尽量减少插值变量，如两个纹理从顶点传到片元，最好存在一个寄存器的xyzw中</p><p>尽量少使用基于屏幕空间的后处理，如果一定需要，使用精度低的变量。</p><p>高精度的运算使用LUT（参考光照衰减）或者转移到定点着色器</p><p>尽量把多个特效合并到一个shdaer，如颜色校正、添加噪声、Bloom等屏幕特效</p><p>少使用sin、tan、pow，换成LUT，少使用分支，少使用discard（影响硬件优化）</p><h3 id="第十八章" tabindex="-1">第十八章 <a class="header-anchor" href="#第十八章" aria-label="Permalink to &quot;第十八章&quot;">​</a></h3><h4 id="次表面散射" tabindex="-1">次表面散射 <a class="header-anchor" href="#次表面散射" aria-label="Permalink to &quot;次表面散射&quot;">​</a></h4><figure><img src="/ayene-no-blog/assets/image-20231008145040160.DakoziKR.png" alt="image-20231008145040160" loading="lazy" decoding="async"></figure><h4 id="高光反射brdf——torrance-sparrow微面元模型" tabindex="-1">高光反射BRDF——Torrance-Sparrow微面元模型 <a class="header-anchor" href="#高光反射brdf——torrance-sparrow微面元模型" aria-label="Permalink to &quot;高光反射BRDF——Torrance-Sparrow微面元模型&quot;">​</a></h4><figure><img src="/ayene-no-blog/assets/image-20231008150214942.BXjlgr8Z.png" alt="image-20231008150214942" loading="lazy" decoding="async"></figure><h4 id="金属工作流和高光反射工作流" tabindex="-1">金属工作流和高光反射工作流 <a class="header-anchor" href="#金属工作流和高光反射工作流" aria-label="Permalink to &quot;金属工作流和高光反射工作流&quot;">​</a></h4><p>金属工作流为默认流程。</p><p>金属工作流并非只能模拟高光物质，他们的名称来源于：</p><ul><li><p>金属工作流定义了材质表面的金属值：是金属还是非金属</p><ul><li><p>Albedo : 物体的整体颜色</p></li><li><p>Metallic : 金属度（越高越像金属）</p></li><li><p>Smoothness ：光滑程度</p></li></ul></li><li><p>高光反射工作流来源于它指定了表面的高光反射颜色等，在金属工作流中这个颜色需要由漫反射颜色和金属值衍生而来</p><ul><li>Albedo : 漫反射强度</li><li>Specular : 高光反射强度</li><li>Smoothness : 光滑程度</li></ul></li></ul><h4 id="反射探针" tabindex="-1">反射探针 <a class="header-anchor" href="#反射探针" aria-label="Permalink to &quot;反射探针&quot;">​</a></h4><p>回想第十章如何使用Cubemap模拟反射结果。</p><p>在场景特定位置对整个场景的环境反射进行采样，结果存储在反射探针中，当游戏中包含反射效果的物体从这些探针附近经过时，Unity会把反射结果传递给这些物体使用的反射纹理。</p><p>简单来说，放置反射探针存储周围的环境反射，从而对拥有反射效果的附近物体产生影响。</p><p>类型：</p><ul><li>Baked：提前烘焙得到cubemap，不会变化，烘焙时只考虑静态物体</li><li>Realtime：实时更新</li><li>Custom：自动以</li></ul><h4 id="伽马校正" tabindex="-1">伽马校正 <a class="header-anchor" href="#伽马校正" aria-label="Permalink to &quot;伽马校正&quot;">​</a></h4><p>人眼感知暗的变化比感知亮的变化更加敏感，所以在8位空间（RGBA的范围为[0, 255]）时，我们采用了更多的空间来存储暗部。</p><p>因此在存储照片时，往往进行了一次加码</p><p>Lout = Lin^2.2 , 如输入0.5 加码后变为0.5^0.22 = 0.21</p><p>这个过程被称为伽马校正</p><p>这时，线性的亮度被转为非线性的，但是图形学中很多计算都是线性的，如光照计算等，因此我们需要确保在进行各类计算时转换到线性空间，当渲染完成，要显示到屏幕上时再进行伽马校正。</p><p>有些输入本身就在非线性空间，这时候我们要将其转换到线性空间进行计算，如纹理等美术人员直接制作出来的图像，当把输入纹理设置成sRGB时，可以自动完成这一转换。</p><figure><img src="/ayene-no-blog/assets/image-20231008162704559.C322xnyI.png" alt="image-20231008162704559" loading="lazy" decoding="async"></figure><h4 id="hdr" tabindex="-1">HDR <a class="header-anchor" href="#hdr" aria-label="Permalink to &quot;HDR&quot;">​</a></h4><p>HDR使用32位的颜色空间，这使我们</p><ul><li>能够抛弃伽马校正，不再需要更多的空间存储暗部信息，而是进行线性存储</li><li>能够存储超过1的亮部，从而保留亮部细节，在LDR中，白色的墙壁和强烈的阳光是相同的颜色，但HDR中阳光可以超过1，从而使得Bloom的阈值更加正确，在最后将HDR映射回[0, 1]时，也能保留更多的亮部细节，不丢失高亮度区域的颜色值。</li></ul><p>缺点在于：</p><ul><li>渲染速度变慢，需要更大的显存空间</li><li>无法利用硬件的抗锯齿功能（尽管我们可以在后处理中进行抗锯齿操作）</li></ul><h4 id="pbr并非是为了更真实的渲染" tabindex="-1">PBR并非是为了更真实的渲染 <a class="header-anchor" href="#pbr并非是为了更真实的渲染" aria-label="Permalink to &quot;PBR并非是为了更真实的渲染&quot;">​</a></h4><p>PBR最大的好处在于：使用一个shader从而能够在各种各样中的环境都正确的显示光照，具有更强的普适性而不用使得同一个材质在不同环境中要编写多个shader。甚至可以用一个shader描绘不同材质的物体，只需要调整特定的参数。</p><!--]--><!--]--><!----><!----></article><!-- </Transition> --><!--]--><!--[--><!--[--><!--[--><!----><ul class="post-copyright" m="y-4"><li class="post-copyright-author"><strong>本文作者：</strong><span>水沢绫音</span></li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://pat-chou-li.github.io/ayene-no-blog/posts/cg/unity shader入门精要" target="_blank" title="本文链接">https://pat-chou-li.github.io/ayene-no-blog/posts/cg/unity shader入门精要</a></li><li class="post-copyright-license"><strong>版权声明：</strong><span>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 ">CC BY-NC-SA</a> 许可协议。</span></li></ul><!--]--><!--]--><!--]--></div><!--]--><!----></div><!--[--><!--]--><!--[--><div class="post-nav"><div class="post-nav-item"><a href="/ayene-no-blog/posts/cg/srp" class="post-nav-prev" title="SRP"><div class="icon" i-ri-arrow-left-s-line></div><span class="title truncate" text="sm">SRP</span></a></div><div class="post-nav-item"><a href="/ayene-no-blog/posts/cg/games101" class="post-nav-next" title="games101"><span class="title truncate" text="sm">games101</span><div class="icon" i-ri-arrow-right-s-line></div></a></div></div><!--]--><!--[--><!--]--><!----><!--[--><!-- eslint-disable-next-line vue/no-lone-template empty --><template class="mt-4"></template><!--]--><!--[--><!--]--><!--[--><!--]--></div><!--]--></main><!--[--><button class="xl:hidden toc-btn shadow-md fixed yun-icon-btn z-20 bg-$va-c-bg-soft" opacity="75" right="4" bottom="19"><div i-ri-file-list-line></div></button><!----><aside flex="~ col" class="va-card yun-aside sticky top-0 lg:top-$yun-margin-top min-h-sm" text="center" overflow="auto"><div class="w-full" flex="~ col" pb-2 style="display:none"><!--[--><h2 m="t-6 b-2" font="serif black">文章目录</h2><div style="display:none" data-v-6dc67c73><div class="content" data-v-6dc67c73><div class="outline-title" data-v-6dc67c73>本页</div><div class="outline-marker" data-v-6dc67c73></div><nav aria-labelledby="doc-outline-aria-label" data-v-6dc67c73><span id="doc-outline-aria-label" class="visually-hidden" data-v-6dc67c73>Table of Contents for current page</span><ul class="root va-toc relative z-1 css-i18n-toc" data-v-6dc67c73 data-v-699db71a><!--[--><!--]--></ul></nav></div></div><!--]--><div class="flex-grow"></div><!----></div></aside><!--]--><!--]--></div><footer flex="~ col" class="relative yun-footer va-footer px-4 py-4 pt-0 text-$va-c-text-light w-full mt-14" bg="white dark:$va-c-bg-soft" text="center sm"><div class="yun-cloud absolute top--10 left-0 right-0"><svg class="waves" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" fill="var(--yun-c-cloud)"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><!----><div class="copyright flex justify-center items-center gap-2" p="1"><span>©<!--[--> 2022 -<!--]--> 2025</span><a class="animate-pulse inline-flex" href="https://www.yunyoujun.cn/sponsors/" target="_blank" title="Sponsor YunYouJun"><div class="i-ri-cloud-line"></div></a><span>水沢绫音</span></div><div class="powered" m="2"><span>由 <a href="git+https://github.com/YunYouJun/valaxy.git" target="_blank" rel="noopener">Valaxy</a> <span class="op-60">v0.26.10</span> 驱动</span><span mx-1>|</span><span><span>主题</span><span mx-1>-</span><a href="git+https://github.com/YunYouJun/valaxy/tree/main/packages/valaxy-theme-yun.git" title="valaxy-theme-yun" target="_blank">Yun</a><span class="ml-1 op-60">v0.26.10</span></span></div><!--[--><!--]--><div class="yun-footer-gradient" style="--gradient-from:161 196 253;--gradient-to:194 233 251"></div></footer><!--]--><!--]--></div><script>window.__INITIAL_STATE__='{"pinia":{"yun-app":{},"app":{"showLoading":true},"site":{},"routerStore":{}}}'</script><script type="application/ld+json" data-hid="schema-org-graph">{"@context":"https://schema.org","@graph":[{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#identity","@type":"Person","name":"水沢绫音","url":"https://pat-chou-li.github.io/ayene-no-blog/","image":{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#/schema/image/658d95f"},"sameAs":["/atom.xml","https://github.com/pat-chou-li","https://www.zhihu.com/people/shui-ze-ling-yin-46","https://space.bilibili.com/8929945?spm_id_from=333.1007.0.0","patchouli13@163.com"]},{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#website","@type":"WebSite","dateModified":"2023-09-29","datePublished":"2023-09-29","inLanguage":"en","name":"Unity shader 入门精要","url":"https://pat-chou-li.github.io/ayene-no-blog/","publisher":{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#identity"}},{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#webpage","@type":"WebPage","dateModified":"2023-09-29T00:00:00.000Z","datePublished":"2023-09-29T00:00:00.000Z","description":"我从来没有觉得学图形学开心过。","name":"Unity shader 入门精要","url":"https://pat-chou-li.github.io/ayene-no-blog/","about":{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#identity"},"isPartOf":{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#website"},"potentialAction":[{"@type":"ReadAction","target":["https://pat-chou-li.github.io/ayene-no-blog/"]}]},{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#article","dateModified":"2023-09-29T00:00:00.000Z","datePublished":"2023-09-29T00:00:00.000Z","description":"我从来没有觉得学图形学开心过。","headline":"Unity shader 入门精要","inLanguage":"en","thumbnailUrl":"https://pat-chou-li.github.io/ayene-no-blog/favicon.svg","@type":["Article","BlogPosting"],"author":{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#/schema/person/6678b6b"},"image":{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#/schema/image/19d7713"},"isPartOf":{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#webpage"},"mainEntityOfPage":{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#webpage"},"publisher":{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#identity"}},{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#/schema/person/6678b6b","@type":"Person","name":"水沢绫音","url":"https://valaxy.site"},{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#/schema/image/658d95f","@type":"ImageObject","contentUrl":"https://raw.githubusercontent.com/pat-chou-li/ayene-no-blog/main/resource/avatar.jpg","inLanguage":"en","url":"https://raw.githubusercontent.com/pat-chou-li/ayene-no-blog/main/resource/avatar.jpg"},{"@id":"https://pat-chou-li.github.io/ayene-no-blog/#/schema/image/19d7713","@type":"ImageObject","contentUrl":"https://pat-chou-li.github.io/ayene-no-blog/favicon.svg","inLanguage":"en","url":"https://pat-chou-li.github.io/ayene-no-blog/favicon.svg"}]}</script></body></html>