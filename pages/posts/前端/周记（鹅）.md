---
title: 周记

date: 2025.4.23

categories: 前端

tags:

 - 前端
 - 鹅
---

### command mode实现编辑

背景：产品希望支持编辑的redo、undo，因此需要设计数据结构以记忆过去行为

实现：

- 定义ICommand接口，每个具体命令需要实现execute(执行)和undo(撤销)两个函数
- 实现CommandInvoker类，该类负责调用命令实例，并存储undo、redo栈
  - 通过单例模式实现全局的invoker实例共享，共享undo、redo栈
  - 编辑时可能会出现竞态问题，通过上锁处理，直到promise落定之后才解锁

设计：单例模式共享undo、redo；竞态问题上锁

### 类腾讯文档复制、粘贴

背景：用户希望支持从腾讯文档或其他表格类的TAPD中，通过复制、粘贴进行编辑，需要支持外源->内源，内源->内源

实现：

- 每个单元格实际上是一个数据结构，例如
  - 人员型会存储用户uid，但显示为用户昵称，输入则是一个人员检索器
  - 时间型存储unix时间戳，但显示为年月日
- 首先我们需要解析外部的表格数据，我们先支持了腾讯文档的表格系统，一开始是使用的自己编写的解析代码，通过\r换单元格，\r\n换行，后来发现不同系统（linux windows）等实现不太一致，所以引用了sheetjs来解析
- 因此，对于外部复制的文本，我们需要对每个类型定制一个converter（转换器），根据它粘贴到的单元格，调用对应的转换器，将数据结构转换为内部可接受的输入类型，例如
  - 粘贴了一个邮箱，我们需要查询邮箱对应的uid是否存在，再update节点
  - 粘贴了一个时间，我们需要dayjs转换为unix时间戳，再update节点
- 相应的，我们需要一个reverseConverter，以支持批量的复制功能，这个主要是支持内源->内源的复制。

设计：

- 通过抽象命令、类型转换表封装了足够的可扩展性，如果要支持更多的数据类型或者修改方式（例如，批量修改可以再实现一个具体命令，支持文件型只需要实现对应的convert）
- 存在单元级别的鉴权，对每个单元格做converter的时候可以增加预处理、后处理，这里会对权限做验证

### 可拖拽放缩element封装

背景：产品提出了el-dialog需要可以拖拽放缩，原生el-dialog不支持这个功能，希望封装一个resizableElDialog组件。

实现：用自定义指令v-resizable，在组件渲染前获取实际dom元素，在右侧，下方和右下分别使用绝对定位添加一个用于拖拽的dom，监听鼠标的点击事件，动态修改el-dialog的width|height。具体来说

- mousedown时记录鼠标初始位置，添加mousemove事件
- mousemove时节流计算鼠标移动距离，调整dilaog尺寸
- mouseup时清除mousemove事件

设计：

- 开闭原则：将组件功能封装成自定义指令，保证替换项目中已有的el-dialog时成本较低，组件变量采用透传
- 性能考虑：对于修改dom元素这种高重排的使用节流函数

### 导出历史

背景：文档有一个下载功能，需要一个导出历史的记录

实现：el-table + el-pagination，对后端拉过来的数据做一个map就好

设计：功能很简单，能设计的地方不多，主要是

- 预加载，导出历史是一个二级界面，在一级界面的时候就可以垃数据把状态存好了
- 现在是前端分页，如果数据量大可以考虑切换成后端分页增加用户体验

### 源码

#### commond mode

```typescript
// import { compositeCopyContent, onCopyHandle } from '../CopyAndPaste/ProgressCopyController';
// import { onPasteHandle, parsePasteContent } from '../CopyAndPaste/ProgressPasteController';
// import { IFormatContent } from '../CopyAndPaste/utils';
// import { BatchSameEditCommand } from './BatchSameEditCommand';

declare global {
  interface Window {
    invoker: CommandInvoker;
  }
}

export interface ICommand {
  execute(): Promise<any>;
  undo(): Promise<any>;
}

export class CommandInvoker {
  private undoStack: ICommand[] = [];
  private redoStack: ICommand[] = [];
  private maxHistory = 100;
  private static instance: CommandInvoker;
  public isProcessing = false; // lock

  private constructor() {}

  public static getInstance(): CommandInvoker {
    if (!CommandInvoker.instance) {
      CommandInvoker.instance = new CommandInvoker();
      window.invoker = this.instance;
      // window.addEventListener('keydown', async (e) => {
      //   if (e.ctrlKey && e.key === 'z') {
      //     CommandInvoker.instance.undo();
      //   }
      //   if (e.ctrlKey && e.key === 'y') {
      //     CommandInvoker.instance.redo();
      //   }
      //   // -------------- TODO : 删除测试代码 --------------------  // debugger
      //   // if (e.ctrlKey && e.key === 'c') {
      //   //   const nodeIds = [120347620397433, 120347620397435];
      //   //   const keys = ['9975edb5-8d12-5797-a6b5-04afbe8572a7'];
      //   //   const formatContent = onCopyHandle(nodeIds, keys);
      //   //   compositeCopyContent(formatContent);
      //   // }

      //   // if (e.ctrlKey && e.key === 'v') {
      //   //   const pasteContent: IFormatContent = await parsePasteContent();
      //   //   const nodeIds = [120347620397433, 120347620397435];
      //   //   const keys = ['schedule_mode', 'name', '5e37b56b-e250-5bb9-b2fd-9a39425e1dd3'];
      //   //   onPasteHandle(pasteContent, nodeIds, keys);
      //   // }
      //   // -------------- TODO : 删除测试代码 --------------------  // debugger
      // });
    }
    return CommandInvoker.instance;
  }

  execute(command: ICommand, needStack: Boolean = true): Promise<any> {
    const res = command.execute();
    if (!needStack) return res;
    this.undoStack.push(command);
    if (this.undoStack.length > this.maxHistory) {
      this.undoStack.shift();
    }
    this.redoStack = [];
    return res;
  }

  async undo() {
    if (this.isLocked()) return;
    const command = this.undoStack.pop();
    if (command) {
      this.lock();
      await command.undo();
      this.redoStack.push(command);
      this.unlock();
    }
  }

  async redo() {
    if (this.isLocked()) return;
    const command = this.redoStack.pop();
    if (command) {
      this.lock();
      await command.execute();
      this.undoStack.push(command);
      this.unlock();
    }
  }

  lock() {
    this.isProcessing = true;
    console.log('lock');
  }

  unlock() {
    this.isProcessing = false;
    console.log('unlock');
  }

  isLocked() {
    return this.isProcessing;
  }
}

```

#### 类腾讯文档复制、粘贴

```typescript
// 复制部分
import ProgressManager from '@/model/progressSystem/ProgressManager';
import {
  IPropertyValue,
  IFormatContent,
  getValueType,
  notifyMsg,
  alarmWithNotifyMsgs,
  NEWLINE,
} from '@/controllers/componentControllers/ProgressPanel/ProgressPropsEditController/CopyAndPaste/utils';
import propertyManager, { Property } from '@/model/templateSystem/Property';

// onPasteHandle的返过程，逆converter + 拼成content
export function onCopyHandle(nodeIds: number[], keys: string[]): IFormatContent {
  const progressManager = ProgressManager.getInstance();
  const nodes = nodeIds.map((id) => progressManager.getNode(id));
  const x = nodeIds.length;
  const y = keys.length;

  // 创建空content
  const content: string[][] = Array.from({ length: x }, () => Array.from({ length: y }, () => ''));
  const notifyMsgs: notifyMsg[] = [];

  for (let i = 0; i < x; i++) {
    const node = nodes[i];
    for (let j = 0; j < y; j++) {
      const key: string = keys[j];

      const propertyOfKey: Property | undefined = propertyManager.getProperty(key);
      if (!propertyOfKey) {
        notifyMsgs.push({ type: 'error', msg: `没有找到该key对应的property: ${key}` });
        content[i][j] = '';
        continue;
      }

      // 鉴权
      const { read } = node.getCustomPropertyPermission(key);
      if (!read) {
        content[i][j] = '';
        const displayName = propertyOfKey?.name ?? key;
        notifyMsgs.push({ type: 'error', msg: `没有读取权限: ${displayName}` });
        continue;
      }

      let propertyValue: IPropertyValue | IPropertyValue[] = node.getCustomProperties(key) ?? node[key] ?? null;

      // IPropertyValue -> (reverse converter + reverse public converter) -> string
      const valueType: string = getValueType(propertyOfKey);
      console.log('类型', valueType);
      const reverseConverter: Function = valueReverseConverterMap[valueType] ?? reverseDefaultConverter;

      if (reverseConverter === reverseUnsupportedConverter) {
        content[i][j] = '';
        reverseUnsupportedConverter(valueType);
        const displayName = propertyOfKey?.name ?? key;
        notifyMsgs.push({ type: 'error', msg: `不支持复制类型: ${valueType}, 具体字段: ${displayName}` });
        continue;
      }

      // null特殊处理, null -> ""
      if (propertyValue === null) {
        content[i][j] = '';
        continue;
      }

      if (Array.isArray(propertyValue)) {
        propertyValue = propertyValue.map((v) => reverseConverter(v, propertyOfKey));
      } else {
        propertyValue = reverseConverter(propertyValue, propertyOfKey);
      }

      const value: string = reversePublicConverter(propertyValue, propertyOfKey);
      content[i][j] = value;
    }
  }
  return { content, x, y, notifyMsgs };
}

export function compositeCopyContent(formatContent: IFormatContent) {
  const notifyFun = typeof window.amNotify === 'function' ? window.amNotify() : null;
  const copyContent: string = formatContent.content
    .map((v) => v.join('\t'))
    .join('\r\n')
    .concat('\r\n');
  console.log(copyContent, 'copyContent');
  const clipboard = window.navigator.clipboard;
  // 使用writeText
  clipboard
    .writeText(copyContent)
    .then(() => {
      if (formatContent.notifyMsgs.some((msg) => msg.type === 'error')) {
        formatContent.notifyMsgs.push({ type: 'error', msg: '上述内容调整为空值，复制成功' });
      } else {
        formatContent.notifyMsgs.push({ type: 'success', msg: '复制成功' });
      }

      alarmWithNotifyMsgs(formatContent.notifyMsgs);
    })
    // 使用write
    // const blob = new Blob([copyContent], { type: 'text/plain' });
    // const item = new ClipboardItem({
    //   'text/plain': blob,
    // });
    // clipboard
    //   .write([item])
    //   .then(() => {
    //     if (formatContent.notifyMsgs.some((msg) => msg.type === 'error')) {
    //       formatContent.notifyMsgs.push({ type: 'error', msg: '上述内容调整为空值，复制成功' });
    //     } else {
    //       formatContent.notifyMsgs.push({ type: 'success', msg: '复制成功' });
    //     }
    //     alarmWithNotifyMsgs(formatContent.notifyMsgs);
    //   })
    .catch((err) => {
      notifyFun && notifyFun.error('请选中单元格，再进行复制操作');
    });
  return clipboard;
}

// TODO : 修改中文key名
// 理论上任何reverseConventer应该负责将IPropertyValue转换为string，这里统一后移到reversePublicConverter
// 因此不同于conventer : IPropertyValue -> string , 这里是 IPropertyValue -> IPropertyValue
const valueReverseConverterMap = {
  // 拥有独立的reverseConverter
  文本型: reverseTextConverter,
  枚举型: reverseEnumConverter,
  日期型: reverseDatetimeConverter,
  数值型: reverseNumberConventer,
  人员型: reversePersonConverter,
  布尔型: reverseBooleanConverter,
  富文本类型: reverseRichTextConverter,

  // 依靠上述的reverseConverter
  进度型: reverseNumberConventer,
  超链接型: reverseTextConverter,
  时长型: reverseNumberConventer,
  多层下拉类型: reverseEnumConverter,

  // unsupported
  关联型: reverseUnsupportedConverter,
  文件型: reverseUnsupportedConverter,
  图片型: reverseUnsupportedConverter,
  其他类型: reverseUnsupportedConverter,
};

function reverseDefaultConverter(value: IPropertyValue, property: Property): IPropertyValue {
  return value;
}

// 将IPropertyValue数组转换为以`,`分割的字符串，单个IPropertyValue转换为string
// 同时，将`\n`转换为`##NEWLINE##`
function reversePublicConverter(value: IPropertyValue | IPropertyValue[], property: Property): string {
  if (Array.isArray(value)) {
    return value.map((v) => v?.toString()?.replaceAll('\n', NEWLINE) ?? '').join(',');
  }
  return value?.toString().replaceAll('\n', NEWLINE) ?? '';
}

// string -> string
function reverseTextConverter(value: IPropertyValue, property: Property): IPropertyValue {
  return value;
}

// key -> display_name
function reverseEnumConverter(value: IPropertyValue, property: Property): IPropertyValue {
  // 存储和view不一致的情况，property中有range.display_name
  if (property?.range?.display_name) {
    const display_name = property.range.display_name;
    return (value && display_name[value]) ?? value;
  }
  // TODO : 容灾处理， 检查在不在enum中
  return value;
}

// unix timestamp -> string
function reverseDatetimeConverter(value: IPropertyValue, property: Property): IPropertyValue {
  return value;
}

// int, float -> string
function reverseNumberConventer(value: IPropertyValue, property: Property): IPropertyValue {
  return value;
}

// account_name -> string, 相信view中的内源数据，不做check
function reversePersonConverter(value: IPropertyValue, property: Property): IPropertyValue {
  return value;
}

// 'true' or 'false' or ''-> string
function reverseBooleanConverter(value: IPropertyValue, property: Property): IPropertyValue {
  return value;
}

function reverseRichTextConverter(value: IPropertyValue, property: Property): IPropertyValue {
  return value;
}

function reverseUnsupportedConverter(valueType: string): IPropertyValue {
  return ``;
}


// 粘贴部分
import propertyManager, { Property } from '@/model/templateSystem/Property';
import {
  IFormatContent,
  getValueType,
  IPropertyValue,
  isUnixTimestamp,
  notifyMsg,
  alarmWithNotifyMsgs,
  NEWLINE,
} from '@/controllers/componentControllers/ProgressPanel/ProgressPropsEditController/CopyAndPaste/utils';
import { CommandInvoker } from '../command/ProgressPropsEditCommand';
import { BatchSameEditCommand } from '../command/BatchSameEditCommand';
import ProgressManager from '@/model/progressSystem/ProgressManager';
import dayjs from 'dayjs';
import customParseFormat from 'dayjs/plugin/customParseFormat';
import NetworkHub from '@/model/common/NetworkHub';
import XLSX from 'xlsx';
import { validataOS } from '@/views/components/Collaboration/MutilTable/utils/device';

// params : pasteContent : string, 粘贴板内容
// 功能 : 解析粘贴板内容，将其转换成符合onPasteHandle入参要求的pasteContent格式
/**
 * 解析粘贴板内容，将其转换成符合要求的pasteContent格式
 * @param pasteContent 粘贴板内容
 * @returns
 */

// 从腾讯智能文档解析出的是xaml，可以被解析，但是xlsx是html，无法解析
async function parseMacOsPasteContent(): Promise<string> {
  const clipboard = navigator.clipboard;
  const pasteContent: Array<ClipboardItem> = await clipboard.read();
  let htmlText: string = '';
  for (const item of pasteContent) {
    if (item.types.includes('text/html')) {
      const blob: Blob = await item.getType('text/html');
      htmlText = await blob.text();
    }
  }
  /* parse each data string into a workbook */
  var wb = XLSX.read(htmlText, { type: 'string' });
  /* get first worksheet from each workbook */
  var ws = wb.Sheets[wb.SheetNames[0]];
  /* generate CSV for each "first worksheet" */
  var result = XLSX.utils.sheet_to_txt(ws);
  result = parseXlsxTxt(result);
  return result;
}

async function parsePasteContent(): Promise<IFormatContent> {
  const notifyFun = typeof window.amNotify === 'function' ? window.amNotify() : null;
  const clipboard = navigator.clipboard;
  let pasteContent;
  try {
    // 使用readText;
    if (validataOS() === 'Mac') {
      pasteContent = await parseMacOsPasteContent();
      console.log(pasteContent);
    } else {
      pasteContent = await clipboard.readText();
    }
    const content = pasteContent
      // 去除最后一个换行符
      .replace(/\r\n$/, '')
      .split('\r\n')
      .map((v) => v.split('\t'));
    const x = content.length;
    const y = content.reduce((acc, v) => Math.max(acc, v.length), 0);
    return { content, x, y, notifyMsgs: [] };
    // 使用read
    // const pasteContent: Array<ClipboardItem> = await clipboard.read();
    // let content: Array<Array<string>> | null = null;
    // for (const item of pasteContent) {
    //   if (item.types.includes('text/plain')) {
    //     const blob: Blob = await item.getType('text/plain');
    //     const text = await blob.text();
    //     content = text
    //       .replace(/\r\n$/, '')
    //       .split('\r\n')
    //       .map((v) => v.split('\t'));
    //   }
    // }
    // const x = content?.length;
    // const y = content?.reduce((acc, v) => Math.max(acc, v.length), 0);
    // if (content && x && y) {
    //   return { content, x, y, notifyMsgs: [] };
    // }
    // notifyFun && notifyFun.error('剪贴板内容无法解析，可能不包含任何文本');
    // return { content: [], x: 0, y: 0, notifyMsgs: [] };
  } catch (err) {
    notifyFun && notifyFun.error('请聚焦到一个单元格中，再进行粘贴操作');
    return { content: [], x: 0, y: 0, notifyMsgs: [] };
  }
}

/**
 *
 * @param nodeIds   从被选中的节点开始，每行的nodeIds
 * @param pasteContent 解析后的粘贴板内容
 * @param keys 从被选中的节点开始，每列的properties
 * @returns properties[], 每个节点的新属性，符合batchUpdateNodePropertyAsSame的参数定义
 */

async function onPasteHandle(formatContent: IFormatContent, nodeIds: number[], keys: string[]) {
  // 超出行时，nodeIds会传-1，超出列时，keys会传空字符串，filter掉
  nodeIds = nodeIds.filter((id) => id !== -1);
  keys = keys.filter((key) => key !== '');

  const progressManager = ProgressManager.getInstance();
  const nodes = nodeIds.map((id) => progressManager.getNode(id));
  formatContent = repeatContent(formatContent, nodeIds, keys);
  let { content, x, y } = formatContent;
  x = Math.min(x, nodeIds.length);
  y = Math.min(y, keys.length);
  let propertyList: any[] = [];
  const notifyMsgs: notifyMsg[] = [];

  for (let i = 0; i < x; i++) {
    const id = nodeIds[i];
    const node = nodes[i];
    for (let j = 0; j < y; j++) {
      const key = keys[j];

      const propertyOfKey: Property | undefined = propertyManager.getProperty(key);
      if (!propertyOfKey) {
        notifyMsgs.push({ type: 'error', msg: `没有找到该key对应的property: ${key}` });
        continue;
      }

      // 鉴权
      const { write } = node.getCustomPropertyPermission(key);
      if (!write) {
        const displayName = propertyOfKey?.name ?? key;
        notifyMsgs.push({ type: 'error', msg: `没有写入权限: ${displayName}` });
        continue;
      }

      const property = {};
      let value: string = content[i][j];

      // content : string -> (public converter + converter) -> IPropertyValue
      const valueType: string = getValueType(propertyOfKey);
      const converter: Function = valueConverterMap[valueType] ?? defaultConverter;

      if (converter === unsupportedConverter) {
        unsupportedConverter(valueType);
        const displayName = propertyOfKey?.name ?? key;
        notifyMsgs.push({ type: 'error', msg: `不支持黏贴类型: ${valueType}, 具体字段: ${displayName}` });
        continue;
      }

      // 空字符串特殊处理， “” -> null
      if (value === '') {
        property['id'] = id;
        property[key] = null;
        propertyList.push(property);
        continue;
      }

      let propertyValue: string | string[] | IPropertyValue | IPropertyValue[] = publicConverter(value, propertyOfKey);
      if (Array.isArray(propertyValue)) {
        propertyValue = await Promise.all(propertyValue.map((v) => converter(v, propertyOfKey, notifyMsgs)));
      } else {
        propertyValue = await converter(propertyValue, propertyOfKey, notifyMsgs);
      }

      // 后端接口不接受数组中存在null的情况，例如人员型有的合法有的不合法，应该把数组中的null去除
      // 如果数组中所有数据都不合法，修改为null
      if (Array.isArray(propertyValue)) {
        propertyValue = propertyValue.filter((v) => v !== null);
      }
      if (Array.isArray(propertyValue) && propertyValue.length === 0) {
        propertyValue = null;
      }

      // 空值在前面处理过了，空值应该覆盖，这时候为null的是不合法的，按PRD保留原始值而不覆盖
      if (propertyValue !== null) {
        property['id'] = id;
        property[key] = propertyValue;
        propertyList.push(property);
      }
    }
  }

  alarmWithNotifyMsgs(notifyMsgs);

  const commandInvoker = CommandInvoker.getInstance();
  commandInvoker.execute(new BatchSameEditCommand(propertyList));
  return propertyList;
}

// 被选中的范围大于粘贴板内容的范围时，重复粘贴板内容
function repeatContent(formatContent: IFormatContent, nodeIds: number[], keys: string[]) {
  const { content, x, y } = formatContent;
  if (nodeIds.length >= x && keys.length >= y) {
    const x1 = parseInt((nodeIds.length / x).toString(), 10) * x;
    const y1 = parseInt((keys.length / y).toString(), 10) * y;
    const newContent = Array.from({ length: x1 }, () => Array.from({ length: y1 }, () => ''));
    for (let i = 0; i < x1; i++) {
      for (let j = 0; j < y1; j++) {
        newContent[i][j] = content[i % x][j % y];
      }
    }
    return { content: newContent, x: x1, y: y1, notifyMsgs: formatContent.notifyMsgs };
  }
  return formatContent;
}

// TODO : 修改中文key名
// 任何conventer应该负责将string转换为IPropertyValue
const valueConverterMap = {
  // 拥有独立的converter
  文本型: textConverter,
  枚举型: enumConverter,
  时间型: datetimeConverter,
  数值型: numberConventer,
  人员型: personConventer,
  布尔型: booleanConverter,
  富文本类型: richTextConverter,

  // 依靠上述的conventer
  进度型: numberConventer,
  超链接型: textConverter,
  时长型: numberConventer,
  多层下拉类型: enumConverter,

  // unsupported
  关联型: unsupportedConverter,
  文件型: unsupportedConverter,
  图片型: unsupportedConverter,
  其他类型: unsupportedConverter,
};

// 以`,`分割的字符串转换为string数组
// 将`##NEWLINE##`转换为`\n`
function publicConverter(value: string, property: Property): string | string[] {
  value = value.replaceAll(NEWLINE, '\n');
  let res: string | string[] = value;
  if (property.type.slice(-2) === '[]') {
    res = res.split(',');
  }
  return res;
}

// function publicConverter(value: string, property: Property): IPropertyValue | IPropertyValue[] {
//   let propertyValue: IPropertyValue | IPropertyValue[] = value;
//   if (property.type.slice(-2) === '[]') {
//     propertyValue = value.split(',');
//   }
//   if (property.type.slice(0, 3) === 'int') {
//     propertyValue = Array.isArray(propertyValue) ? propertyValue.map((v) => parseInt(v as string)) : parseInt(propertyValue);
//   } else if (property.type.slice(0, 5) === 'float') {
//     propertyValue = Array.isArray(propertyValue) ? propertyValue.map((v) => parseFloat(v as string)) : parseFloat(propertyValue);
//   }
//   return propertyValue;
// }

function defaultConverter(value: string, property: Property): IPropertyValue {
  return value;
}

function textConverter(value: string, property: Property): IPropertyValue {
  return value;
}

// string(display_name) -> key
function enumConverter(value: string, property: Property): IPropertyValue {
  // 存储和view不一致的情况，property中有range.display_name
  if (property?.range?.display_name) {
    const display_name = property.range.display_name;
    let keys = Object.keys(display_name);
    for (let i = 0, len = keys.length; i < len; i++) {
      if (display_name[keys[i]] === value) {
        return keys[i];
      }
    }
  }
  if (property?.range?.enum) {
    const enumValue = property.range.enum;
    if (enumValue.indexOf(value) !== -1) {
      return value;
    }
  }
  return null;
}

// string -> unix timestamp(number)
function datetimeConverter(value: string, property: Property, notifyMsgs: notifyMsg[]): IPropertyValue {
  dayjs.extend(customParseFormat);
  if (isUnixTimestamp(value)) {
    return parseInt(value);
  }
  // TODO : 补充时间格式
  const datetime = dayjs(value, ['YYYY-M-D', 'YYYY-MM-DD', 'DD/MM/YYYY']);
  if (!datetime.isValid()) {
    notifyMsgs.push({ type: 'error', msg: `时间格式错误: ${value}` });
    return null;
  }
  return datetime.valueOf();
}

// 解析string，根据property的type转换为int或float
function numberConventer(value: string, property: Property): IPropertyValue {
  if (property?.type.slice(0, 3) === 'int') {
    return parseInt(value);
  } else if (property?.type.slice(0, 5) === 'float') {
    return parseFloat(value);
  }
  return null;
}

// check account if exist (for one account)
async function personConventer(value: string, property: Property, notifyMsgs: notifyMsg[]): Promise<IPropertyValue> {
  const users = (await new NetworkHub().checkAccountIfExist({ account_name: [value] })) ?? [];
  if (users.length == 0) {
    notifyMsgs.push({ type: 'error', msg: `用户不存在: ${value}` });
    return null;
  }
  return value;
}

// 任意字符 -> 'true' or 'false' or ''
function booleanConverter(value: string, property: Property): IPropertyValue {
  const trueList = ['true', '1', '正确', '√'];
  const falseList = ['false', '0', '错误', '×'];
  if (trueList.includes(value)) {
    return 'true';
  } else if (falseList.includes(value)) {
    return 'false';
  }
  return null;
}

function richTextConverter(value: string, property: Property): IPropertyValue {
  return value;
}

function unsupportedConverter(valueType: string): IPropertyValue {
  return null;
}

// 被""包裹的内容，去掉""，其中的换行符不变
// 不被""包裹的内容，换行符替换成/r/n
function parseXlsxTxt(result: string): string {
  let inQuote = false;
  let res = '';
  for (let i = 0; i < result.length; i++) {
    if (result[i] === '"') {
      inQuote = !inQuote;
    } else if (result[i] === '\n' && !inQuote) {
      res += '\r\n';
    } else {
      res += result[i];
    }
  }
  return res;
}

export { parsePasteContent, onPasteHandle };

```



#### 可拖拽放缩

```vue
<template>
  <div class="dialogContainer" v-resizable>
    <el-dialog v-bind="$attrs" class="resizable-dialog">
      <template v-for="(_, name) in $slots" #[name]="slotProps">
        <slot :name="name" v-bind="slotProps"></slot>
      </template>
    </el-dialog>
  </div>
</template>

<script lang="ts" setup>
import { ElDialog } from 'element-plus';
defineOptions({
  inheritAttrs: false,
});

// resizeEnd 会传出拖拽结束时的鼠标位置
const emit = defineEmits<{
  (e: 'resizeStart'): void;
  (e: 'resizeEnd', x: number, y: number): void;
}>();

enum ResizeDirection {
  WIDTH = 'width',
  HEIGHT = 'height',
  BOTH = 'both',
}

const createResizeEl = (direction, dragDom, dragDomHeight) => {
  const resizeEl = document.createElement('div');
  resizeEl.style.cursor = direction === ResizeDirection.WIDTH ? 'w-resize' : direction === ResizeDirection.HEIGHT ? 'n-resize' : 'nw-resize';
  resizeEl.style.position = 'absolute';
  resizeEl.style.height = direction === ResizeDirection.HEIGHT || direction === ResizeDirection.BOTH ? '10px' : '100%';
  resizeEl.style.width = direction === ResizeDirection.WIDTH || direction === ResizeDirection.BOTH ? '10px' : '100%';
  // 根据方向调整位置
  if (direction === ResizeDirection.WIDTH) {
    resizeEl.style.right = '-5px';
    resizeEl.style.top = '0';
  } else if (direction === ResizeDirection.HEIGHT) {
    resizeEl.style.bottom = '-5px';
    resizeEl.style.left = '0';
  } else if (direction === ResizeDirection.BOTH) {
    resizeEl.style.right = '-5px';
    resizeEl.style.bottom = '-5px';
  }

  resizeEl.onmousedown = (e) => {
    emit('resizeStart');
    e.preventDefault();
    // 创建一个元素覆盖在文本编辑器上，触发mouseMove，否则鼠标移动到文本编辑器内就不会触发move事件
    let coverEl = document.createElement('div');
    coverEl.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;z-index:9999';
    coverEl.style.width = '100%';
    coverEl.style.height = '100%';
    coverEl.style.cursor = resizeEl.style.cursor;
    document.body.appendChild(coverEl);
    //计算初始鼠标位置和弹窗宽高
    let startX = e.clientX;
    let startY = e.clientY;
    let width = parseInt(window.getComputedStyle(dragDom).width);
    let height = parseInt(window.getComputedStyle(dragDomHeight).height);
    // 鼠标拖动事件
    const onMouseMove = (e) => {
      let endX = e.clientX;
      let endY = e.clientY;
      let deltaX = endX - startX;
      let deltaY = endY - startY;
      // 高度拉伸不需要修改宽度
      if (direction !== ResizeDirection.HEIGHT) {
        dragDom.style.width = width + deltaX + 'px';
      }
      // 宽度拉伸不需要修改高度
      if (direction !== ResizeDirection.WIDTH) {
        dragDomHeight.style.height = height + deltaY + 'px';
      }
    };
    // 鼠标抬起事件
    const onMouseUp = (e) => {
      window.removeEventListener('mousemove', onMouseMove, true);
      window.removeEventListener('mouseup', onMouseUp, true);
      document.body.removeChild(coverEl);
      emit('resizeEnd', e.clientX, e.clientY);
    };
    window.addEventListener('mousemove', onMouseMove, true);
    window.addEventListener('mouseup', onMouseUp, true);
  };

  return resizeEl;
};

const vResizable = {
  updated: (el: any) => {
    el.style.pointerEvents = 'none';
    let dragDom = document.querySelector('.resizable-dialog') as HTMLElement;
    let dragDomHeight = document.querySelector('.resizable-dialog .el-dialog__body') as HTMLElement;
    if (!dragDom || !dragDomHeight) return;
    dragDomHeight.style.height = '600px'; // 默认高度
    // 最小宽高
    dragDom.style.minWidth = '500px';
    dragDomHeight.style.minHeight = '300px';

    // 宽度拉伸时由于margin 0 auto自动居中，会导致左右一起变长，换一种居中方式
    dragDom.style.margin = '15vh 0 0 0';
    dragDom.style.position = 'absolute';
    // 这里不能用自身大小百分比居中，不然还是会左右一起变长,需要用固定大小
    const width = parseInt(window.getComputedStyle(dragDom).width);
    dragDom.style.left = dragDom.style.left || `calc(50% - ${width / 2}px)`;

    // 宽度拉伸
    let resizeElR = createResizeEl(ResizeDirection.WIDTH, dragDom, dragDomHeight);
    dragDom?.appendChild(resizeElR);

    // 高度拉伸
    let resizeElB = createResizeEl(ResizeDirection.HEIGHT, dragDom, dragDomHeight);
    dragDom?.appendChild(resizeElB);

    // 宽高拉伸
    let resizeElRB = createResizeEl(ResizeDirection.BOTH, dragDom, dragDomHeight);
    dragDom?.appendChild(resizeElRB);
  },
};
</script>
```

